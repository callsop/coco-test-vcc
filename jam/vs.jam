###########################################################################################
#
# microsoft visual studio
#


VS = "C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Tools\\MSVC" ;

if ! [ Exists $(VS) ]
{
	VS = "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC" ;
}

rule CheckVS
{
    local check = $(>:E=$(VS)) ;
    if ! [ Exists $(check) ] 
    {
        Echo "Microsoft Visual Studio $(<) not found at:" ;
        Echo $(check) ;
        Exit "Please install and/or set VS to path of Visual Studio MSVC directory in vs.jam." ;
    }
    else 
    {
        if $(<) && $(VERBOSE)
        {
            Echo Using $(<) at $(check) ;
        }
    }
}

CheckVS ;

# uncomment this to use a specific version:
# VS_VER = 14.42.34433 ;

# not set try to find a version
if ! $(VS_VER) 
{
    local versions = [ Glob $(VS)\\ : * ] ;
    versions = [ Reverse [ Exclude . .. : $(versions:BS) ] ] ;
    if $(versions)
    {
        VS_VER = $(versions[1]) ;
        if $(VERBOSE)
        {
            Echo Using Visual Studio Ver: $(VS_VER) ;
        }
    }
}

VS = $(VS)\\$(VS_VER) ;

CheckVS ;

###########################################################################################
#
# microsoft linker defaults
#

LINK = "$(VS)\\bin\\Hostx86\\x86\\link.exe" ;
LINKFLAGS += /nologo /subsystem:windows ;
LINKPATH += "$(VS)\\lib\\x86" ;

# as the library paths have spaces, use an environment variable and quote executable
actions Link bind NEEDLIBS
{
    set LIBPATH= /libpath:"$(LINKPATH)"
    "$(LINK)" /DEBUG /out:$(<) $(LINKFLAGS) $(UNDEFS) %LIBPATH% $(LINKLIBS) $(NEEDLIBS) $(>)
}

###########################################################################################
#
# c++ defaults
#

C++FLAGS = /nologo /FS /Gd /Zi /std:c++20 /W3 /EHsc /Zc:strictStrings- ;
C++FLAGS on debug = $(C++FLAGS) /MDd /Od /D_DEBUG ;
C++FLAGS on release = $(C++FLAGS) /MD /O2 /DNDEBUG ;

C++ = "$(VS)\\bin\\Hostx86\\x86\\cl.exe" ;
INCLUDE += $(VS)\\include ;
 
# as the include paths have spaces, use an environment variable and quote executable
actions C++
{
    set INCL= /I"$(INCLUDE)"
    "$(C++)" /c /Fo$(<) /Fd$(<:S=.pdb) $(C++FLAGS) %INCL% $(CCDEFS) $(CCHDRS) $(>)
}

actions Cc
{
    set INCL= /I"$(INCLUDE)"
    "$(C++)" /c /Fo$(<) /Fd$(<:S=.pdb) $(CC++FLAGS) %INCL% $(CCDEFS) $(CCHDRS) $(>)
}


CheckVS cl.exe : $(C++) ;
CheckVS link.exe : $(LINK) ;


#
# Resource files
#


rule Rc t : s
{
	# build resource outputs into their own directory to avoid name clash
	local LOCATE_TARGET = [ FDirName $(LOCATE_TARGET) rc ] ;
	local SOURCE_GRIST = [ FGrist $(SOURCE_GRIST) rc ] ;

	Depends $(<) : $(>) ;
	Depends res : $(<) ;
	NotFile res ;
	FLAGS on $(<) = /nologo /I 0x0409 ;
	INCLUDES on $(<) = $(WINSDK_INC) $(SEARCH_SOURCE) ;
	MakeLocate $(<) : $(LOCATE_TARGET) ;
}

actions Rc
{
	set INCL= /I"$(INCLUDES)" 
	"$(RC)" $(FLAGS) %INCL% /fo$(<) $(>)
}

rule UserObject t : s
{
	switch $(>:S)
	{
		case .rc : Rc $(<) : $(>) ;
	}
}

rule FGristFiles files
{
	local f l ;
	local RC_SOURCE_GRIST = [ FGrist $(SOURCE_GRIST) rc ] ;
	for f in $(files)
	{
		switch $(f:S)
		{
			# no need to re-grist object files
			case .obj : l += $(f) ;

			# handle rc files to avoid name clashes
			case .rc : l += $(f:G=$(RC_SOURCE_GRIST)) ;

			# default grist
			case * : l += $(f:G=$(SOURCE_GRIST:E)) ;
		}
	}
	return $(l) ;
}
