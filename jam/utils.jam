SPEACE = " " ;
NEWLINE = "
" ;


#
# Call rul for each configuration.
#
# e.g. ForEachConfig debug release : Main main : $(srcs) ;
#
rule ForEachConfig cfgs : rul
{
    local cfg ;
    for cfg in $(cfgs)
    {
        NotFile $(cfg) ;
        on $(cfg) $(rul[1]) $(cfg) : $(rul[2]) : $(3) : $(4) : $(5) ;
    }
}

#
# Print contents of each var.
#
# EchoVar var var var ;
#
rule EchoVar vars
{
    local f ;
    for v in $(vars)
    {
        Echo $(v) \= $($(v)) ;
    }
}

#
# Exists f - is true if 'f' exists.
#
rule Exists
{
    local p = <checked>$(<:P) ;

    if $(VERBOSE) >= 5
    {
        EchoVar p ;
    }

    if ! $($(p))
    {
        local files = [ Glob $(<:P) : * ] ;
        $(p) = $(files:BS) ;
    }

    if $(<:BS) in $($(p))
    {
        if $(VERBOSE) >= 5
        {
            Echo Found $(<:BS) ;
        }
        return 1 ;
    }

    return ;
}

#
# Glob all paths in 'path' for 'pattern'
#
rule GlobRecursive path : pattern
{
	local l ;
	local paths = [ Glob $(path) : * ] ;
	local results = [ Glob $(path) : $(pattern) ] ;

	for l in $(paths)
	{
		if ! $(l:S)
		{
			results += [ GlobRecursive $(l) : $(pattern) ] ;
		}
	}
	return $(results) ;
}

#
# Strip duplicates from list.
#
rule Unique list
{
	local i ;
	local results ;
	for i in $(list)
	{
		if ! $(i) in $(results)
		{
			results += $(i) ;
		}
	}
	return $(results) ;
}

#
# Exclude these : fromThis - excludes first list from second list
#
rule Exclude
{
    local i result ;
    for i in $(2)
    {
        if ! ( $(i) in $(1) )
        {
            result += $(i) ;
        }
    }
    return $(result) ;
}

#
# Reverse list - reverses list elements
#
rule Reverse
{
	local result ;
	for i in $(<)
	{
		result = $(i) $(result) ;
	}
	return $(result) ;
}